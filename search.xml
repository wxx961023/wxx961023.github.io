<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Vue重构有赞商城]]></title>
    <url>%2F2019%2F05%2F09%2FVue%E9%87%8D%E6%9E%84%E6%9C%89%E8%B5%9E%E5%95%86%E5%9F%8E%2F</url>
    <content type="text"><![CDATA[一、记录我踩到的坑（1）、未绑定数据:(踩坑次数：2) 二、课程的重点部分（1）、左侧导航栏切换 采用到class和style的绑定问题 点击进行切换，就是绑定事件@click=&quot;&quot;绑定原生事件，做一个识别和请求，对后台的数据做请求，做请求就是传id,请求二级分类。把一级分类id传到二级分类，根据id进行相应的请求。（点击一级获取二级）相对应的需要在JS中把方法getSublist()定义出来我们在浏览器中看下id是否传过来了我们可以看到点击4个选择分别传的id为：800、810、817、811 把数组的下标传进来，进行切换用v-show=&quot;topIndex ===0&quot; （2）、左侧导航栏焦点状态的处理，其实就是一个类加载的问题我们在这就已经写死了状态为active，我们需要把这里删除，重新绑定 （3）、商品价格的处理，用过滤器html代码：1&lt;div class=&quot;price&quot;&gt;￥&#123;&#123;list.price | numFilter&#125;&#125;&lt;/div&gt; js代码：12345filters:&#123; numFilter(price)&#123; return price.toFixed(2) &#125;&#125; 注意：必须是Number类型数据才能使用toFixed() 方法，但是vue中获取的数据通常为String格式，所以这里用Number处理一下数据。]]></content>
      <tags>
        <tag>demo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[09-阐述内容、样式和行为分离]]></title>
    <url>%2F2019%2F04%2F15%2F09-%E9%98%90%E8%BF%B0%E5%86%85%E5%AE%B9%E3%80%81%E6%A0%B7%E5%BC%8F%E5%92%8C%E8%A1%8C%E4%B8%BA%E5%88%86%E7%A6%BB%2F</url>
    <content type="text"><![CDATA[这是面试时候可能遇到的一道题 一、先说观点 我认为内容、样式和行为分离，根据W3C标准来说，就是html负责内容，CSS负责样式，JS负责行为。 二、提供论据 类似这样的题目，如果正面不好回答的情况下，可以尝试反着回答，如人为什么要吃饭，答：如果人不吃饭就会饿死！ 假设html控制样式，如图 用&lt;center&gt;标签把文字居中，然后用&lt;strong&gt;加粗文字。 这样的写法把原本简单的逻辑结构变得复杂话，不利于代码的维护。 如果html也负责样式的话，使得内容的结构有很多无用的标签，有的标签表示内容，有的标签表示样式，这样我就很难区分内容的逻辑结构 假设用CSS写内容 这样写会导致用户选取不到文字 而且JS取不到这里的文本内容 假如用CSS控制行为，那么CSS里面有很复杂的逻辑，会导致CSS很慢，最终影响页面加载速度 假设用JS控制样式 还没写$div.hiden()之前 写了$div.hiden()之后，文字就被隐藏 加上$div.show()文字又出现那么问题来了 在$div.show()之后，div的属性为display: block;，那么有可能在$div.hiden()之前,原本的div标签属性是display: flex;，经过$div.show()改变了属性的值为block，那么页面的flex布局就会全局炸掉。 三、总结 为了以后改版时更方便，直接修改样式，而不动HTML的内容。更方便易于阅读样式和内容，便于项目的维护。 网页的内容直接暴露在搜索引擎面前，这样有利于搜索引擎抓取网页的内容。]]></content>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[08-模拟jQuery实现两个需求]]></title>
    <url>%2F2019%2F04%2F14%2F08-%E6%A8%A1%E6%8B%9FjQuery%E5%AE%9E%E7%8E%B0%E4%B8%A4%E4%B8%AA%E9%9C%80%E6%B1%82%2F</url>
    <content type="text"><![CDATA[一、需求如下 123456window.jQuery = ???window.$ = jQueryvar $div = $(&apos;div&apos;)$div.addClass(&apos;red&apos;) // 可将所有 div 的 class 添加一个 red$div.setText(&apos;hi&apos;) // 可将所有 div 的 textContent 变为 hi 题目中要求将所有 div 的 class 添加一个 red，以及将所有 div 的 textContent 变为 hi。 二、解决思路 jQuery本质就是一个构造函数然后接受一个参数（这个参数可能是节点）并返回一个nodes对象。 首先我们要能用var \$div = $(‘div’)获取到所有 div 。 1234567891011121314window.jQuery = function (nodeOrSelector)&#123; var nodes = &#123;&#125; if(typeof nodeOrSelector === &apos;string&apos;)&#123; var temp = document.querySelectorAll(nodeOrSelector) for(let i = 0; i &lt; temp.length; i++)&#123; nodes[i] = temp[i] &#125; nodes.length = temp.length &#125;else if(nodeOrSelector instanceof Node)&#123; nodes = &#123;o: nodeOrSelector,length: 1&#125; &#125; return nodes &#125;window.$ = jQuery 此时，var $div = $(&#39;div&#39;)中的$div 就是上述代码中的 nodes，是一个 value 为所有 div 的伪数组。而且，nodes 需要 return 出去，才能被外面的代码调用。$div.addClass(&#39;red&#39;)可将所有 div 的 class 添加一个 red，$div.setText(&#39;hi&#39;)可将所有 div 的 textContent 变为 hi，我们给 nodes 添加两个 hash ，即，名为 addClass 和 setText 的函数 123456nodes.addClass = function()&#123; &#125;nodes.setText = function()&#123; &#125; 三、完整代码 123456789101112131415161718192021222324252627window.jQuery = function (nodeOrSelector)&#123; var nodes = &#123;&#125; if(typeof nodeOrSelector === &apos;string&apos;)&#123; var temp = document.querySelectorAll(nodeOrSelector) for(let i = 0; i &lt; temp.length; i++)&#123; nodes[i] = temp[i] &#125; nodes.length = temp.length &#125;else if(nodeOrSelector instanceof Node)&#123; nodes = &#123;o: nodeOrSelector,length: 1&#125;; &#125; nodes.addClass = function(classes)&#123; for(let i = 0; i &lt; nodes.length; i++)&#123; nodes[i].classList.add(classes) &#125; &#125; nodes.setText = function(text)&#123; for(let i = 0; i &lt; nodes.length; i++)&#123; nodes[i].textContent = text &#125; &#125; return nodes&#125;window.$ = jQueryvar $div = $(&apos;div&apos;)$div.addClass(&apos;red&apos;) $div.setText(&apos;hi&apos;) 四、总结 在我看来jQuery就是将一个DOM对象重新包装成jQuery对象，这个jQuery对象中包含了许多DOM中不能轻松实现的方法（函数），可以省去很多复杂的代码。 jQuery的基本设计思想和主要用法，就是”选择某个网页元素，然后对其进行某种操作”。 使用jQuery的第一步，往往就是将一个选择表达式，放进构造函数jQuery()（简写为$），然后得到被选中的元素。 首先，声明一个全局函数jQuery，函数通过传参数，通过判断参数的类型及参数是否为节点元素来获取对应的nodes，函数里写有addClass方法和setText方法。 .addClass方法通过传参数（样式的className），遍历所有nodes并加上提供的class类 .setText方法，把文本内容当作参数传递到函数中，遍历所有的nodes并通过textContent属性改变标签的文本内容]]></content>
  </entry>
  <entry>
    <title><![CDATA[07-JS初试封装函数]]></title>
    <url>%2F2019%2F04%2F13%2F07-JS%E5%88%9D%E8%AF%95%E5%B0%81%E8%A3%85%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[一、封装两个函数 相关内容：1234567&lt;ul&gt; &lt;li id = &quot;item1&quot;&gt;选项1&lt;/li&gt; &lt;li id = &quot;item2&quot;&gt;选项2&lt;/li&gt; &lt;li id = &quot;item3&quot;&gt;选项3&lt;/li&gt; &lt;li id = &quot;item4&quot;&gt;选项4&lt;/li&gt; &lt;li id = &quot;item5&quot;&gt;选项5&lt;/li&gt;&lt;/ul&gt; 1. 需求：获取到一个节点的兄弟姐妹，并放到一个伪数组里。1234document.body.nextElementSibling//获取节点的弟弟document.body.previousElementSibling//获取节点的哥哥 初步思路：123456789var allChildren = item3.parentNode.chiledren //获取节点的所有兄弟姐妹var array = &#123;length:0&#125; //创建一个空对象for(let i = 0; i &lt; alllChildren.length; i++)&#123; //遍历 if(allChildren[i] !== item3)&#123; array[array.length] = allChildren[i] array.length += 1 &#125;&#125;console.log(array) //&#123;0:li#itme1, 1:li#itme2, 2:li#itme4, 3:li#itme5, length: 4&#125; 为什么array[array.length]中用array.length不用i，因为它中间有可能跳过一个，跳过之后序号就不一致 为什么不用push？因为这是一个伪数组（伪数组就是哈希）。 封装函数：function 起个好用又好听的名字(){}123456789101112131415function getSiblings(node)&#123; //外部输入一个节点 API var allChildren = node.parentNode.chiledren //获取节点的所有兄弟姐妹 var array = &#123;length:0&#125; //创建一个空对象 for(let i = 0; i &lt; alllChildren.length; i++)&#123; //遍历 if(allChildren[i] !== node)&#123; array[array.length] = allChildren[i] array.length += 1 &#125; &#125;retuen array&#125;console.log(getSiblings(item3)) //&#123;0:li#itme1, 1:li#itme2, 2:li#itme4, 3:li#itme5, length: 4&#125;``` ### 2. 需求：给节点添加`class`，既能`add`也能`remove`。初步思路： item3.classList.add(‘a’)item3.classList.add(‘b’)item3.classList.add(‘c’)123```var classes = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]classes.forEach((value) =&gt; item3.classList.add(value)) 12345678var classes = &#123;&apos;a&apos;:ture, &apos;b&apos;:false, &apos;c&apos;:ture&#125;var value = classes[key]for(let key in classes)&#123; if(value)&#123; item3.classList.add(key) &#125;else&#123; item3.classList.remove(key)&#125; 封装函数：12345678910function addClass(node,classes)&#123; //classes有使用者提供 var value = classes[key] for(let key in classes)&#123; if(value)&#123; node.classList.add(key) &#125;else&#123; node.classList.remove(key) &#125;&#125;用法： addClass（item3, &#123;&apos;a&apos;:ture, &apos;b&apos;:false, &apos;c&apos;:ture&#125;） 优化代码：1234567function addClass(node,classes)&#123; var value = classes[key] for(let key in classes)&#123; var methodName = value ? &apos;add&apos;:&apos;remove&apos; node.Classlist[methodName](key) &#125; &#125; 优化守则： 如果出现类似的代码，就存在优化的可能。 3. 需求：有什么办法让别人知道这两个API有关联性，因为这两个API都是在操作节点命名空间：123456window.ffdom = &#123;&#125;ffdom.getSibilings = getSiblingsffdom.addClass = addClassffdom.getSibilings(item3)ffdom.addClass（item3, &#123;&apos;a&apos;:ture, &apos;b&apos;:false, &apos;c&apos;:ture&#125;） 不命名空间的缺点： 别人不知道你的库叫什么 不知不觉把全局变量覆盖 4. 需求：我想写成item.getSibilings12345678910111213141516171819Node.prototype.getSibilings = function()&#123; var allChildren = this.parentNode.chiledren var array = &#123;length:0&#125; for(let i = 0; i &lt; alllChildren.length; i++)&#123; if(allChildren[i] !== this)&#123; array[array.length] = allChildren[i] array.length += 1 &#125; &#125; retuen array&#125;Node.prototype.addClass = function(classes)&#123; var value = classes[key] for(let key in classes)&#123; var methodName = value ? &apos;add&apos;:&apos;remove&apos; this.Classlist[methodName](key) &#125; &#125;console.log(item3.getSiblings（）) //&#123;0:li#itme1, 1:li#itme2, 2:li#itme4, 3:li#itme5, length: 4&#125; 因为我们篡改了所有Node的公有属性，添加了一个getSiblings的方法。 this就是.前面的东西（这里就是item3） 调用call 1item3.getSiblings.call（item3） 我自己写一个更好的Node2版本，用新的版本去调用第一个版本]]></content>
  </entry>
  <entry>
    <title><![CDATA[JS的数据类型]]></title>
    <url>%2F2019%2F04%2F06%2FJS%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[JavaScript数据类型概述 在JS中一共有六种数据类型 String 字符串(基本数据类型) Number 数值(基本数据类型) Boolean 布尔值(基本数据类型) Null 空值(基本数据类型) Symbol 符号(基本数据类型) Undefined 未定义(基本数据类型) Object 对象(引用数据类型) 字符串类型 String用于表示一个字符序列，即字符串 字符串需要使用 ’或“ 括起来 12345var str1 = &quot;hello&quot;;var str2 = `gz`;var str5 = `hello gz&quot;; // falseconsole.log(typeof str1 ); // stringconsole.log(typeof str2); // string 相同引号不能嵌套，不同引号可以嵌套 双引号不能放双引号，单引号不能放单引号1234var str3 = &quot;hello &quot;gz&quot;&quot;; // falsevar str4 = `hello `gz``; // falsevar str5 = &quot;hello &apos;gz&apos;&quot;; // truevar str6 = `hello &quot;gz&quot;`;// true 给变量加上引号, 那么变量将变为一个常量 123var num = 110;console.log(num); // 输出变量中的值console.log(&quot;num&quot;); // 输出常量num Number类型 在JS中所有的数值都是Number类型(整数和小数) 1234var num1= 123;var num2= 3.14;console.log(typeof num1); // numberconsole.log(typeof num2); // number 由于内存的限制，ECMAScript 并不能保存世界上所有的数值 最大值：Number.MAX_VALUE1console.log(Number.MAX_VALUE); // 1.7976931348623157e+308 最小值：Number.MIN_VALUE 1console.log(Number.MIN_VALUE); // 5e-324 无穷大：Infinity, 如果超过了最大值就会返回该值 1console.log(Number.MAX_VALUE + Number.MAX_VALUE); // Infinity 无穷小：-Infinity, 如果超过了最小值就会返回该值 12console.log(typeof Infinity); // numberconsole.log(typeof -Infinity); // number NaN 非法数字（Not A Number）,JS中当对数值进行计算时没有结果返回，则返回NaN 12var num3 = NaN;console.log(typeof num3); // number Number类型注意点 JS中整数的运算可以保证精确的结果12var sum1 = 10 + 20;console.log(sum1); // 30 在JS中浮点数的运算可能得到一个不精确的结果 12var sum1 = 10.1 + 21.1;console.log(sum1); // 31.200000000000003 Boolean 布尔值 布尔型也被称为逻辑值类型或者真假值类型 布尔型只能够取真（true）和假（false）两种数值 1234var bool1 = true;var bool2 = false;console.log(typeof bool1); // booleanconsole.log(typeof bool2); // boolean 虽然Boolean 类型的字面值只有两个，但 ECMAScript 中所有类型的值都有与这两个 Boolean 值等价的值 任何非零数值都是true, 包括正负无穷大, 只有0和NaN是false 任何非空字符串都是true, 只有空字符串是false 任何对象都是true, 只有null和undefined是false1234567891011121314151617181920var bool3 = Boolean(0);console.log(bool3); // falsevar bool4 = Boolean(1);console.log(bool4); // truevar bool5 = Boolean(-1);console.log(bool4); // truevar bool6 = Boolean(Infinity);console.log(bool4); // truevar bool7 = Boolean(-Infinity);console.log(bool4); // truevar bool8 = Boolean(NaN);console.log(bool8); // falsevar bool9 = Boolean(undefined);console.log(bool8); // falsevar bool10 = Boolean(null);console.log(bool8); // falsevar bool11 = Boolean(&quot;&quot;);console.log(bool8); // falsevar bool12 = Boolean(&quot;abc&quot;);console.log(bool12); // true Null和Undefined Undefined这是一种比较特殊的类型，表示变量未赋值，这种类型只有一种值就是undefined 12var num;console.log(num); //结果是undefined undefined是Undefined类型的字面量 前者undefined和10, “abc”一样是一个常量 后者Undefined和Number,Boolean一样是一个数据类型 需要注意的是typeof对没有初始化和没有声明的变量都会返回undefined。`var value1 = undefined;console.log(typeof value); //结果是undefined var value2;console.log(typeof value2); //结果是undefined]]></content>
  </entry>
  <entry>
    <title><![CDATA[开博大吉]]></title>
    <url>%2F2019%2F04%2F06%2F%E5%BC%80%E5%8D%9A%E5%A4%A7%E5%90%89%2F</url>
    <content type="text"><![CDATA[哈哈哈哈]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F04%2F06%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>

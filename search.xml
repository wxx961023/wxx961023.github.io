<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[08-模拟jQuery实现两个需求]]></title>
    <url>%2F2019%2F04%2F14%2F08-%E6%A8%A1%E6%8B%9FjQuery%E5%AE%9E%E7%8E%B0%E4%B8%A4%E4%B8%AA%E9%9C%80%E6%B1%82%2F</url>
    <content type="text"><![CDATA[一、需求如下 123456window.jQuery = ???window.$ = jQueryvar $div = $(&apos;div&apos;)$div.addClass(&apos;red&apos;) // 可将所有 div 的 class 添加一个 red$div.setText(&apos;hi&apos;) // 可将所有 div 的 textContent 变为 hi 题目中要求将所有 div 的 class 添加一个 red，以及将所有 div 的 textContent 变为 hi。 二、解决思路 jQuery本质就是一个构造函数然后接受一个参数（这个参数可能是节点）并返回一个nodes对象。 首先我们要能用var \$div = $(‘div’)获取到所有 div 。 1234567891011121314window.jQuery = function (nodeOrSelector)&#123; var nodes = &#123;&#125; if(typeof nodeOrSelector === &apos;string&apos;)&#123; var temp = document.querySelectorAll(nodeOrSelector) for(let i = 0; i &lt; temp.length; i++)&#123; nodes[i] = temp[i] &#125; nodes.length = temp.length &#125;else if(nodeOrSelector instanceof Node)&#123; nodes = &#123;o: nodeOrSelector,length: 1&#125; &#125; return nodes &#125;window.$ = jQuery 此时，var $div = $(&#39;div&#39;)中的$div 就是上述代码中的 nodes，是一个 value 为所有 div 的伪数组。而且，nodes 需要 return 出去，才能被外面的代码调用。$div.addClass(&#39;red&#39;)可将所有 div 的 class 添加一个 red，$div.setText(&#39;hi&#39;)可将所有 div 的 textContent 变为 hi，我们给 nodes 添加两个 hash ，即，名为 addClass 和 setText 的函数 123456nodes.addClass = function()&#123; &#125;nodes.setText = function()&#123; &#125; 三、完整代码 123456789101112131415161718192021222324252627window.jQuery = function (nodeOrSelector)&#123; var nodes = &#123;&#125; if(nodeOrSelector === &apos;string&apos;)&#123; var temp = document.querySeletorAll(nodeOrSelector) for(let i = 0; i &lt; temp.length; i++)&#123; nodes[i] = temp[i] &#125; nodes.length = temp.length &#125;else if(nodeOrSelector instanceof Node)&#123; nodes = &#123;o: nodeOrSelector,length: 1&#125;; &#125; nodes.addClass = function(classes)&#123; for(let i = 0; i &lt; nodes.length; i++)&#123; nodes[i].classList.add(classes) &#125; &#125; nodes.setText = function(text)&#123; for(let i = 0; i &lt; nodes.length; i++)&#123; nodes[i].textContent = text &#125; &#125; return nodes&#125;window.$ = jQueryvar $div = $(&apos;div&apos;)$div.addClass(&apos;red&apos;) $div.setText(&apos;hi&apos;) 四、总结 在我看来jQuery就是将一个DOM对象重新包装成jQuery对象，这个jQuery对象中包含了许多DOM中不能轻松实现的方法（函数），可以省去很多复杂的代码。 jQuery的基本设计思想和主要用法，就是”选择某个网页元素，然后对其进行某种操作”。 使用jQuery的第一步，往往就是将一个选择表达式，放进构造函数jQuery()（简写为$），然后得到被选中的元素。 首先，声明一个全局函数jQuery，函数通过传参数，通过判断参数的类型及参数是否为节点元素来获取对应的nodes，函数里写有addClass方法和setText方法。 .addClass方法通过传参数（样式的className），遍历所有nodes并加上提供的class类 .setText方法，把文本内容当作参数传递到函数中，遍历所有的nodes并通过textContent属性改变标签的文本内容]]></content>
  </entry>
  <entry>
    <title><![CDATA[07-JS初试封装函数]]></title>
    <url>%2F2019%2F04%2F13%2F07-JS%E5%88%9D%E8%AF%95%E5%B0%81%E8%A3%85%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[一、封装两个函数 相关内容：1234567&lt;ul&gt; &lt;li id = &quot;item1&quot;&gt;选项1&lt;/li&gt; &lt;li id = &quot;item2&quot;&gt;选项2&lt;/li&gt; &lt;li id = &quot;item3&quot;&gt;选项3&lt;/li&gt; &lt;li id = &quot;item4&quot;&gt;选项4&lt;/li&gt; &lt;li id = &quot;item5&quot;&gt;选项5&lt;/li&gt;&lt;/ul&gt; 1. 需求：获取到一个节点的兄弟姐妹，并放到一个伪数组里。1234document.body.nextElementSibling//获取节点的弟弟document.body.previousElementSibling//获取节点的哥哥 初步思路：123456789var allChildren = item3.parentNode.chiledren //获取节点的所有兄弟姐妹var array = &#123;length:0&#125; //创建一个空对象for(let i = 0; i &lt; alllChildren.length; i++)&#123; //遍历 if(allChildren[i] !== item3)&#123; array[array.length] = allChildren[i] array.length += 1 &#125;&#125;console.log(array) //&#123;0:li#itme1, 1:li#itme2, 2:li#itme4, 3:li#itme5, length: 4&#125; 为什么array[array.length]中用array.length不用i，因为它中间有可能跳过一个，跳过之后序号就不一致 为什么不用push？因为这是一个伪数组（伪数组就是哈希）。 封装函数：function 起个好用又好听的名字(){}123456789101112131415function getSiblings(node)&#123; //外部输入一个节点 API var allChildren = node.parentNode.chiledren //获取节点的所有兄弟姐妹 var array = &#123;length:0&#125; //创建一个空对象 for(let i = 0; i &lt; alllChildren.length; i++)&#123; //遍历 if(allChildren[i] !== node)&#123; array[array.length] = allChildren[i] array.length += 1 &#125; &#125;retuen array&#125;console.log(getSiblings(item3)) //&#123;0:li#itme1, 1:li#itme2, 2:li#itme4, 3:li#itme5, length: 4&#125;``` ### 2. 需求：给节点添加`class`，既能`add`也能`remove`。初步思路： item3.classList.add(‘a’)item3.classList.add(‘b’)item3.classList.add(‘c’)123```var classes = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]classes.forEach((value) =&gt; item3.classList.add(value)) 12345678var classes = &#123;&apos;a&apos;:ture, &apos;b&apos;:false, &apos;c&apos;:ture&#125;var value = classes[key]for(let key in classes)&#123; if(value)&#123; item3.classList.add(key) &#125;else&#123; item3.classList.remove(key)&#125; 封装函数：12345678910function addClass(node,classes)&#123; //classes有使用者提供 var value = classes[key] for(let key in classes)&#123; if(value)&#123; node.classList.add(key) &#125;else&#123; node.classList.remove(key) &#125;&#125;用法： addClass（item3, &#123;&apos;a&apos;:ture, &apos;b&apos;:false, &apos;c&apos;:ture&#125;） 优化代码：1234567function addClass(node,classes)&#123; var value = classes[key] for(let key in classes)&#123; var methodName = value ? &apos;add&apos;:&apos;remove&apos; node.Classlist[methodName](key) &#125; &#125; 优化守则： 如果出现类似的代码，就存在优化的可能。 3. 需求：有什么办法让别人知道这两个API有关联性，因为这两个API都是在操作节点命名空间：123456window.ffdom = &#123;&#125;ffdom.getSibilings = getSiblingsffdom.addClass = addClassffdom.getSibilings(item3)ffdom.addClass（item3, &#123;&apos;a&apos;:ture, &apos;b&apos;:false, &apos;c&apos;:ture&#125;） 不命名空间的缺点： 别人不知道你的库叫什么 不知不觉把全局变量覆盖 4. 需求：我想写成item.getSibilings12345678910111213141516171819Node.prototype.getSibilings = function()&#123; var allChildren = this.parentNode.chiledren var array = &#123;length:0&#125; for(let i = 0; i &lt; alllChildren.length; i++)&#123; if(allChildren[i] !== this)&#123; array[array.length] = allChildren[i] array.length += 1 &#125; &#125; retuen array&#125;Node.prototype.addClass = function(classes)&#123; var value = classes[key] for(let key in classes)&#123; var methodName = value ? &apos;add&apos;:&apos;remove&apos; this.Classlist[methodName](key) &#125; &#125;console.log(item3.getSiblings（）) //&#123;0:li#itme1, 1:li#itme2, 2:li#itme4, 3:li#itme5, length: 4&#125; 因为我们篡改了所有Node的公有属性，添加了一个getSiblings的方法。 this就是.前面的东西（这里就是item3） 调用call 1item3.getSiblings.call（item3） 我自己写一个更好的Node2版本，用新的版本去调用第一个版本]]></content>
  </entry>
  <entry>
    <title><![CDATA[JS的数据类型]]></title>
    <url>%2F2019%2F04%2F06%2FJS%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[JavaScript数据类型概述 在JS中一共有六种数据类型 String 字符串(基本数据类型) Number 数值(基本数据类型) Boolean 布尔值(基本数据类型) Null 空值(基本数据类型) Symbol 符号(基本数据类型) Undefined 未定义(基本数据类型) Object 对象(引用数据类型) 字符串类型 String用于表示一个字符序列，即字符串 字符串需要使用 ’或“ 括起来 12345var str1 = &quot;hello&quot;;var str2 = `gz`;var str5 = `hello gz&quot;; // falseconsole.log(typeof str1 ); // stringconsole.log(typeof str2); // string 相同引号不能嵌套，不同引号可以嵌套 双引号不能放双引号，单引号不能放单引号1234var str3 = &quot;hello &quot;gz&quot;&quot;; // falsevar str4 = `hello `gz``; // falsevar str5 = &quot;hello &apos;gz&apos;&quot;; // truevar str6 = `hello &quot;gz&quot;`;// true 给变量加上引号, 那么变量将变为一个常量 123var num = 110;console.log(num); // 输出变量中的值console.log(&quot;num&quot;); // 输出常量num Number类型 在JS中所有的数值都是Number类型(整数和小数) 1234var num1= 123;var num2= 3.14;console.log(typeof num1); // numberconsole.log(typeof num2); // number 由于内存的限制，ECMAScript 并不能保存世界上所有的数值 最大值：Number.MAX_VALUE1console.log(Number.MAX_VALUE); // 1.7976931348623157e+308 最小值：Number.MIN_VALUE 1console.log(Number.MIN_VALUE); // 5e-324 无穷大：Infinity, 如果超过了最大值就会返回该值 1console.log(Number.MAX_VALUE + Number.MAX_VALUE); // Infinity 无穷小：-Infinity, 如果超过了最小值就会返回该值 12console.log(typeof Infinity); // numberconsole.log(typeof -Infinity); // number NaN 非法数字（Not A Number）,JS中当对数值进行计算时没有结果返回，则返回NaN 12var num3 = NaN;console.log(typeof num3); // number Number类型注意点 JS中整数的运算可以保证精确的结果12var sum1 = 10 + 20;console.log(sum1); // 30 在JS中浮点数的运算可能得到一个不精确的结果 12var sum1 = 10.1 + 21.1;console.log(sum1); // 31.200000000000003 Boolean 布尔值 布尔型也被称为逻辑值类型或者真假值类型 布尔型只能够取真（true）和假（false）两种数值 1234var bool1 = true;var bool2 = false;console.log(typeof bool1); // booleanconsole.log(typeof bool2); // boolean 虽然Boolean 类型的字面值只有两个，但 ECMAScript 中所有类型的值都有与这两个 Boolean 值等价的值 任何非零数值都是true, 包括正负无穷大, 只有0和NaN是false 任何非空字符串都是true, 只有空字符串是false 任何对象都是true, 只有null和undefined是false1234567891011121314151617181920var bool3 = Boolean(0);console.log(bool3); // falsevar bool4 = Boolean(1);console.log(bool4); // truevar bool5 = Boolean(-1);console.log(bool4); // truevar bool6 = Boolean(Infinity);console.log(bool4); // truevar bool7 = Boolean(-Infinity);console.log(bool4); // truevar bool8 = Boolean(NaN);console.log(bool8); // falsevar bool9 = Boolean(undefined);console.log(bool8); // falsevar bool10 = Boolean(null);console.log(bool8); // falsevar bool11 = Boolean(&quot;&quot;);console.log(bool8); // falsevar bool12 = Boolean(&quot;abc&quot;);console.log(bool12); // true Null和Undefined Undefined这是一种比较特殊的类型，表示变量未赋值，这种类型只有一种值就是undefined 12var num;console.log(num); //结果是undefined undefined是Undefined类型的字面量 前者undefined和10, “abc”一样是一个常量 后者Undefined和Number,Boolean一样是一个数据类型 需要注意的是typeof对没有初始化和没有声明的变量都会返回undefined。`var value1 = undefined;console.log(typeof value); //结果是undefined var value2;console.log(typeof value2); //结果是undefined]]></content>
  </entry>
  <entry>
    <title><![CDATA[开博大吉]]></title>
    <url>%2F2019%2F04%2F06%2F%E5%BC%80%E5%8D%9A%E5%A4%A7%E5%90%89%2F</url>
    <content type="text"><![CDATA[哈哈哈哈]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F04%2F06%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
